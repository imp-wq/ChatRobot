## 搭建keras

```python
# 1. 定义网络模型
    #定义序列模型
    model=Sequential()
    #创建输入层
    model.add(Dense(32, input_dim=784))
    model.add(Dense(32, input_dim=784))
    # #创建隐藏层
    model.add(Activation('relu'))
    # #创建输出层
    model.add(Activation('sigmoid'))

    # 2. 编译网络
    # 用均方误差损失和RMSProp编译模型#optimizer
    model.compile(optimizer='rmsprop', loss='mse')

    # 3. 训练和拟合网络
    # 训练模型，对 32 个样本的批次数据进行迭代，使用反向传播算法
    model.fit(data, labels, epochs=10, batch_size=32)
```

## 聊天机器人

```python
#question = Input((max_question_len, batch_size))

    input_encoder_m = Sequential()
    input_encoder_m.add(Embedding(input_dim=vocab_len, output_dim=64))
    input_encoder_m.add(Dropout(0.3))

    match = dot([input_encoded_m, question_encoded], axes=(2, 2))
    match = Activation('softmax')(match)

    response = add([match, input_encoded_c])
    response = Permute((2, 1))(response)
    answer = concatenate([response, question_encoded])

    answer = LSTM(32)(answer)
    answer = Dropout(0.5)(answer)
    # Output layer:
    answer = Dense(vocab_len)(answer)
    # Output shape: (Samples, Vocab_size)  # Yes or no and all 0s
    answer = Activation('softmax')(answer)

    model = Model([input_sequence, question], answer)
    model.compile(optimizer='rmsprop', loss='categorical_crossentropy', metrics=['accuracy'])

    # 保存模型
    filename = 'medium_chatbot_1000_epochs.h5'
    model.save(filename)

    # 加载模型
    model.load_weights('medium_chatbot_1000_epochs.h5')

    # 生成结果
    pred_results = model.predict(([inputs_test, questions_test]))

```

